---
interface Ingredient {
  name?: string;
  ingredient?: string;
  amount?: number | string | null;
  quantity?: string;
  unit?: string | null;
  note?: string | null;
  group?: string;
}

interface Props {
  ingredients: Ingredient[];
  servings?: number | string;
}

const { ingredients, servings = 6 } = Astro.props;

// Always display for 3 persons
const DISPLAY_SERVINGS = 3;
const baseServings = typeof servings === 'string' ? parseInt(servings) : servings;
const scale = DISPLAY_SERVINGS / baseServings;

// Normalize units (kg → g, L → ml) and round up
function normalizeUnit(unit: string, amount: number): { amount: number; unit: string } {
  const lowerUnit = unit.toLowerCase();

  if (lowerUnit === 'kg') {
    return { amount: Math.ceil(amount * 1000), unit: 'g' };
  }
  if (lowerUnit === 'l') {
    return { amount: Math.ceil(amount * 1000), unit: 'ml' };
  }

  return { amount: Math.ceil(amount), unit };
}

// Scale and normalize ingredients
const scaledIngredients = ingredients.map((ing) => {
  const ingredientName = ing.name || ing.ingredient || '';
  const rawAmount = ing.amount || ing.quantity || '';
  const originalUnit = ing.unit || '';

  // If no amount, return as-is
  if (!rawAmount || isNaN(parseFloat(rawAmount.toString()))) {
    return {
      name: ingredientName,
      amount: rawAmount,
      unit: originalUnit,
      note: ing.note,
      group: ing.group,
    };
  }

  const numericAmount = parseFloat(rawAmount.toString());
  const scaledAmount = numericAmount * scale;

  // Normalize units and round up
  const { amount: finalAmount, unit: finalUnit } = normalizeUnit(originalUnit, scaledAmount);

  return {
    name: ingredientName,
    amount: finalAmount.toString(),
    unit: finalUnit,
    note: ing.note,
    group: ing.group,
  };
});

// Group ingredients by their group field
const groupedIngredients = scaledIngredients.reduce((acc, ingredient) => {
  const group = ingredient.group || 'Zutaten';
  if (!acc[group]) {
    acc[group] = [];
  }
  acc[group].push(ingredient);
  return acc;
}, {} as Record<string, any[]>);
---

<section class="bg-white rounded-lg p-8 mb-8">
  <div class="mb-6 pb-4 border-b border-gray-200">
    <h2 class="text-2xl font-bold text-gray-900">
      Zutaten <span class="text-gray-500 font-normal">für {DISPLAY_SERVINGS} Personen</span>
    </h2>
  </div>

  {Object.entries(groupedIngredients).map(([group, items]) => (
    <div class="mb-6 last:mb-0">
      <div class="bg-gray-50 rounded-lg p-6 border border-gray-200">
        {group !== 'Zutaten' && (
          <h3 class="text-lg font-semibold text-gray-900 mb-4">{group}</h3>
        )}
        <ul class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-x-8 gap-y-3">
          {items.map((ingredient) => (
            <li class="flex gap-2 text-gray-700">
              <span class="flex-1">
                {ingredient.amount && (
                  <strong class="text-gray-900">
                    {ingredient.amount}
                  </strong>
                )}{' '}
                {ingredient.unit && <span class="text-gray-600">{ingredient.unit}</span>}{' '}
                <span class="text-gray-900">{ingredient.name}</span>
                {ingredient.note && <span class="text-sm text-gray-500 italic block mt-0.5">({ingredient.note})</span>}
              </span>
            </li>
          ))}
        </ul>
      </div>
    </div>
  ))}
</section>
